# üß† Guia Completo dos Patterns de Agentes de IA

Este documento explica em detalhes cada pattern implementado no BudgetSphere, com exemplos pr√°ticos e casos de uso.

## üìã **√çndice de Patterns**

1. [ReAct Pattern](#react-pattern)
2. [Planning Pattern](#planning-pattern)
3. [Reflection Pattern](#reflection-pattern)
4. [Multi-Agent Pattern](#multi-agent-pattern)
5. [Tool Use Pattern](#tool-use-pattern)

---

## üîÑ **ReAct Pattern**

### **Conceito**
O ReAct (Reasoning and Acting) √© um pattern que combina racioc√≠nio e a√ß√£o de forma iterativa. O agente observa, raciocina sobre o que observou, e ent√£o age baseado nesse racioc√≠nio.

### **Implementa√ß√£o no BudgetSphere**

**Arquivo**: `ReactAgent.java`

```java
public AgentResponse process(String input, Map<String, Object> context) {
    // STEP 1: OBSERVE - Observar a situa√ß√£o
    String observation = observe(input, context);
    
    // STEP 2: REASON - Raciocinar sobre os dados
    String reasoning = reason(observation, context);
    
    // STEP 3: ACT - Decidir a√ß√£o
    String action = act(reasoning, context);
    
    return createResponseWithReasoning(message, data, reasoning, action, true);
}
```

### **Quando Usar**
- An√°lise de despesas an√¥malas
- Detec√ß√£o de padr√µes de gasto
- Alertas proativos
- Diagn√≥stico financeiro

### **Exemplo Pr√°tico**

**Entrada**: "Gastei R$ 2000 em alimenta√ß√£o este m√™s"

**Processo**:
1. **OBSERVE**: "O usu√°rio gastou R$ 2000 em alimenta√ß√£o em um m√™s"
2. **REASON**: "Este valor est√° muito acima da m√©dia recomendada de 15% da renda para alimenta√ß√£o"
3. **ACT**: "Criar alerta e sugerir revis√£o dos h√°bitos alimentares"

**Teste**:
```bash
curl -X POST http://localhost:8080/api/v1/budgetsphere/analyze \
  -H "Content-Type: application/json" \
  -d '{"input": "Gastei R$ 2000 em alimenta√ß√£o este m√™s"}'
```

### **Vantagens**
- Racioc√≠nio expl√≠cito e audit√°vel
- Decis√µes baseadas em l√≥gica clara
- F√°cil debug e melhoria
- Transpar√™ncia no processo

---

## üìã **Planning Pattern**

### **Conceito**
O Planning Pattern foca na cria√ß√£o de planos estruturados e otimizados. Analisa a situa√ß√£o atual, cria um plano detalhado e o otimiza baseado em melhores pr√°ticas.

### **Implementa√ß√£o no BudgetSphere**

**Arquivo**: `PlanningAgent.java`

```java
public AgentResponse process(String input, Map<String, Object> context) {
    // STEP 1: ANALYZE - Analisar situa√ß√£o atual
    String analysis = analyze(input, context);
    
    // STEP 2: PLAN - Criar plano estruturado
    String plan = createPlan(analysis, context);
    
    // STEP 3: OPTIMIZE - Otimizar o plano
    String optimizedPlan = optimize(plan, context);
    
    return createResponse(optimizedPlan, data, true);
}
```

### **Quando Usar**
- Cria√ß√£o de or√ßamentos mensais
- Planejamento de metas financeiras
- Estrat√©gias de economia
- Planos de investimento

### **Exemplo Pr√°tico**

**Entrada**: "Quero economizar R$ 1000 por m√™s"

**Processo**:
1. **ANALYZE**: Analisa renda atual, gastos fixos, padr√µes de consumo
2. **PLAN**: Cria plano com metas espec√≠ficas, estrat√©gias e cronograma
3. **OPTIMIZE**: Ajusta o plano para ser mais realista e eficiente

**Teste**:
```bash
curl -X POST http://localhost:8080/api/v1/budgetsphere/plan \
  -H "Content-Type: application/json" \
  -d '{"goal": "Quero economizar R$ 1000 por m√™s"}'
```

### **Caracter√≠sticas do Plano Gerado**
- **Objetivo Principal**: Meta clara e mensur√°vel
- **Metas Espec√≠ficas**: Valores e prazos definidos
- **Estrat√©gias**: Como alcan√ßar cada meta
- **Cronograma**: Passos mensais
- **Indicadores**: Como medir sucesso

---

## ü™û **Reflection Pattern**

### **Conceito**
O Reflection Pattern implementa aprendizado cont√≠nuo atrav√©s da an√°lise retrospectiva. Revisa resultados passados, reflete sobre o que funcionou, e aprende para melhorar futuras decis√µes.

### **Implementa√ß√£o no BudgetSphere**

**Arquivo**: `ReflectionAgent.java`

```java
public AgentResponse process(String input, Map<String, Object> context) {
    // STEP 1: REVIEW - Revisar dados hist√≥ricos
    String review = review(input, context);
    
    // STEP 2: REFLECT - Refletir sobre padr√µes
    String reflection = reflect(review, context);
    
    // STEP 3: LEARN - Extrair aprendizados
    String learning = learn(reflection, context);
    
    return createResponse(learning, data, true);
}
```

### **Quando Usar**
- An√°lise mensal/trimestral de resultados
- Melhoria cont√≠nua de estrat√©gias
- Identifica√ß√£o de padr√µes comportamentais
- Ajuste de metas e planos

### **Exemplo Pr√°tico**

**Entrada**: "√∫ltimos 3 meses"

**Processo**:
1. **REVIEW**: Revisa gastos, metas atingidas, decis√µes tomadas
2. **REFLECT**: Identifica o que funcionou bem e o que n√£o funcionou
3. **LEARN**: Extrai li√ß√µes e define melhorias espec√≠ficas

**Teste**:
```bash
curl -X POST http://localhost:8080/api/v1/budgetsphere/reflect \
  -H "Content-Type: application/json" \
  -d '{"period": "√∫ltimos 3 meses"}'
```

### **Tipos de Reflex√£o**
- **Resultados Alcan√ßados**: O que foi conquistado
- **Padr√µes Identificados**: Comportamentos recorrentes
- **Li√ß√µes Aprendidas**: Insights importantes
- **Melhorias Futuras**: A√ß√µes concretas

---

## üë• **Multi-Agent Pattern**

### **Conceito**
O Multi-Agent Pattern orquestra m√∫ltiplos agentes especializados para resolver problemas complexos. Um supervisor decide quais agentes usar e como combinar seus resultados.

### **Implementa√ß√£o no BudgetSphere**

**Arquivo**: `SupervisorAgent.java`

```java
public AgentResponse process(String input, Map<String, Object> context) {
    // STEP 1: ROUTE - Decidir qual agente usar
    String routing = route(input, context);
    
    // STEP 2: COORDINATE - Executar agentes apropriados
    List<AgentResponse> responses = coordinate(routing, input, context);
    
    // STEP 3: SYNTHESIZE - Combinar resultados
    String synthesis = synthesize(responses, context);
    
    return createResponse(synthesis, data, true);
}
```

### **Estrat√©gias de Orquestra√ß√£o**
- **SINGLE**: Usa apenas um agente especializado
- **SEQUENTIAL**: Executa agentes em sequ√™ncia
- **PARALLEL**: Executa m√∫ltiplos agentes simultaneamente

### **Quando Usar**
- Problemas complexos que requerem m√∫ltiplas perspectivas
- Situa√ß√µes que se beneficiam de diferentes tipos de an√°lise
- Quando precisar combinar planejamento, an√°lise e reflex√£o

### **Exemplo Pr√°tico**

**Entrada**: "Preciso de ajuda com meu or√ßamento mensal"

**Processo**:
1. **ROUTE**: Decide usar PlanningAgent + ReactAgent
2. **COORDINATE**: Executa ambos os agentes
3. **SYNTHESIZE**: Combina plano estruturado com an√°lise situacional

**Teste**:
```bash
curl -X POST http://localhost:8080/api/v1/budgetsphere/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "Preciso de ajuda com meu or√ßamento mensal"}'
```

### **Vantagens**
- Combina especialidades diferentes
- Resultados mais completos e robustos
- Flexibilidade na escolha de estrat√©gias
- Escalabilidade para novos agentes

---

## üõ†Ô∏è **Tool Use Pattern**

### **Conceito**
O Tool Use Pattern permite que agentes executem ferramentas especializadas para tarefas espec√≠ficas. Implementa descoberta din√¢mica, valida√ß√£o e execu√ß√£o segura de ferramentas.

### **Implementa√ß√£o no BudgetSphere**

**Arquivos**: 
- `FinancialTool.java` (interface)
- `BudgetCalculatorTool.java` (implementa√ß√£o)
- `ExpenseAnalyzerTool.java` (implementa√ß√£o)
- `ToolRegistry.java` (registro)

```java
public interface FinancialTool {
    String getName();
    String getDescription();
    Map<String, Object> execute(Map<String, Object> parameters);
    boolean validateParameters(Map<String, Object> parameters);
}
```

### **Ferramentas Implementadas**

#### 1. **BudgetCalculator**
- **Fun√ß√£o**: Aplica regra 50/30/20 para distribui√ß√£o de or√ßamento
- **Entrada**: `monthlyIncome`
- **Sa√≠da**: Distribui√ß√£o detalhada por categorias

#### 2. **ExpenseAnalyzer**
- **Fun√ß√£o**: Analisa padr√µes de despesas e detecta anomalias
- **Entrada**: Lista de despesas
- **Sa√≠da**: Estat√≠sticas, padr√µes e anomalias

### **Exemplo Pr√°tico - BudgetCalculator**

**Teste**:
```bash
curl -X POST http://localhost:8080/api/v1/budgetsphere/tools/BudgetCalculator \
  -H "Content-Type: application/json" \
  -d '{"monthlyIncome": "5000"}'
```

**Resposta**:
```json
{
  "success": true,
  "monthlyIncome": 5000,
  "needs": 2500.00,
  "wants": 1500.00,
  "savings": 1000.00,
  "rule": "50/30/20",
  "categories": {
    "moradia": 1000.00,
    "alimentacao": 750.00,
    "transporte": 500.00,
    "outros_essenciais": 250.00,
    "lazer": 750.00,
    "compras": 450.00,
    "entretenimento": 300.00,
    "emergencia": 600.00,
    "investimentos": 400.00
  }
}
```

### **Como Adicionar Nova Ferramenta**

1. **Implementar a interface**:
```java
@Component
public class NovaFerramenta implements FinancialTool {
    @Override
    public String getName() { return "NovaFerramenta"; }
    
    @Override
    public String getDescription() { return "Descri√ß√£o da ferramenta"; }
    
    @Override
    public Map<String, Object> execute(Map<String, Object> parameters) {
        // Implementa√ß√£o da l√≥gica
    }
    
    @Override
    public boolean validateParameters(Map<String, Object> parameters) {
        // Valida√ß√£o dos par√¢metros
    }
}
```

2. **Registrar no ToolRegistry**:
```java
@Autowired
public ToolRegistry(BudgetCalculatorTool budgetCalculator, 
                   ExpenseAnalyzerTool expenseAnalyzer,
                   NovaFerramenta novaFerramenta) {
    registerTool(budgetCalculator);
    registerTool(expenseAnalyzer);
    registerTool(novaFerramenta);
}
```

---

## üîó **Combinando Patterns**

### **Exemplo: An√°lise Completa de Or√ßamento**

1. **Tool Use**: Calcular distribui√ß√£o ideal com BudgetCalculator
2. **ReAct**: Analisar gastos atuais vs distribui√ß√£o ideal
3. **Planning**: Criar plano para ajustar gastos
4. **Reflection**: Revisar progresso ap√≥s implementa√ß√£o

### **Fluxo Integrado**
```
Entrada do Usu√°rio
       ‚Üì
SupervisorAgent (Multi-Agent)
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ReactAgent  ‚îÇPlanningAgent‚îÇReflectionAgent‚îÇ
‚îÇ (An√°lise)   ‚îÇ (Plano)     ‚îÇ (Aprendizado) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì
Ferramentas (Tool Use)
       ‚Üì
Resposta Sintetizada
```

---

## üìä **Compara√ß√£o dos Patterns**

| Pattern | Foco | Quando Usar | Sa√≠da Principal |
|---------|------|-------------|-----------------|
| **ReAct** | An√°lise + A√ß√£o | Problemas imediatos | Diagn√≥stico + A√ß√£o |
| **Planning** | Estrutura√ß√£o | Metas futuras | Plano detalhado |
| **Reflection** | Aprendizado | Melhoria cont√≠nua | Li√ß√µes + Melhorias |
| **Multi-Agent** | Orquestra√ß√£o | Problemas complexos | Solu√ß√£o integrada |
| **Tool Use** | Execu√ß√£o | C√°lculos espec√≠ficos | Resultados precisos |

---

## üéØ **Melhores Pr√°ticas**

### **Para Implementa√ß√£o**
1. **Mantenha cada pattern focado** em sua responsabilidade espec√≠fica
2. **Use logging detalhado** para debug e auditoria
3. **Implemente valida√ß√£o** de entrada em todos os agentes
4. **Documente o racioc√≠nio** de cada decis√£o

### **Para Uso**
1. **Escolha o pattern certo** para cada tipo de problema
2. **Combine patterns** para solu√ß√µes mais robustas
3. **Use o SupervisorAgent** quando n√£o souber qual pattern usar
4. **Monitore os logs** para entender o comportamento

### **Para Extens√£o**
1. **Siga as interfaces existentes** ao adicionar novos agentes
2. **Implemente testes** para cada novo pattern
3. **Mantenha a documenta√ß√£o** atualizada
4. **Use dependency injection** para facilitar testes

---

**Este guia demonstra como cada pattern resolve problemas espec√≠ficos e como podem ser combinados para criar solu√ß√µes mais poderosas e inteligentes.**

